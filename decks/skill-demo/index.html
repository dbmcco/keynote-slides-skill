<!doctype html>
<!-- ABOUTME: Single-file Keynote-style slide deck template with brand tokens and Gemini hooks. -->
<!-- ABOUTME: Includes slide layouts, navigation, and optional media generation controls. -->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Keynote Slides Skill Demo</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400,600,700&family=Space+Grotesk:wght@400;500;600&display=swap");

      :root {
        --brand-ink: #0d1117;
        --brand-ink-soft: #18202a;
        --brand-paper: #f7f1e8;
        --brand-paper-deep: #efe3d4;
        --brand-accent: #ff6b35;
        --brand-accent-strong: #ff4d1a;
        --brand-sage: #93a77a;
        --brand-slate: #3a4654;
        --brand-line: rgba(13, 17, 23, 0.12);
        --brand-glow: rgba(255, 107, 53, 0.35);
        --font-display: "Fraunces", "Iowan Old Style", "Palatino", serif;
        --font-body: "Space Grotesk", "Avenir Next", "Gill Sans", sans-serif;
        --slide-radius: 28px;
        --slide-shadow: 0 24px 60px rgba(13, 17, 23, 0.18);
        --slide-border: 1px solid rgba(13, 17, 23, 0.08);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: var(--font-body);
        color: var(--brand-ink);
        background:
          radial-gradient(circle at 15% 20%, rgba(255, 107, 53, 0.12), transparent 55%),
          radial-gradient(circle at 85% 8%, rgba(147, 167, 122, 0.18), transparent 45%),
          linear-gradient(180deg, #fdf8f0 0%, #f4eadf 45%, #ede0d2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 6vh 4vw 10vh;
      }

      .deck {
        position: relative;
        width: min(1200px, 92vw);
        height: min(720px, 72vh);
      }

      .slide {
        position: absolute;
        inset: 0;
        opacity: 0;
        transform: translateY(12px) scale(0.985);
        transition: opacity 0.5s ease, transform 0.5s ease;
        pointer-events: none;
      }

      .slide.is-active {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }

      .slide-inner {
        height: 100%;
        background: var(--brand-paper);
        border-radius: var(--slide-radius);
        box-shadow: var(--slide-shadow);
        border: var(--slide-border);
        padding: clamp(28px, 4vw, 56px);
        display: grid;
        gap: clamp(16px, 2.4vh, 28px);
        overflow: hidden;
      }

      .theme-ink .slide-inner {
        background: #0f141b;
        color: #f7f1e8;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .theme-ink .chip,
      .theme-ink .card,
      .theme-ink .media-frame {
        border-color: rgba(255, 255, 255, 0.12);
      }

      .layout-title {
        align-content: center;
        grid-template-rows: auto;
      }

      .layout-split {
        grid-template-columns: 1.1fr 0.9fr;
        align-items: center;
      }

      .layout-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
        align-content: start;
      }

      .layout-metrics {
        grid-template-columns: repeat(3, minmax(0, 1fr));
        align-content: center;
      }

      .layout-quote {
        align-content: center;
        text-align: center;
      }

      .eyebrow {
        text-transform: uppercase;
        letter-spacing: 0.24em;
        font-size: 0.7rem;
        font-weight: 600;
        color: var(--brand-accent);
      }

      .title {
        font-family: var(--font-display);
        font-size: clamp(2.8rem, 5vw, 4.4rem);
        line-height: 1.05;
        margin: 0;
      }

      .subtitle {
        font-size: clamp(1rem, 1.6vw, 1.35rem);
        line-height: 1.5;
        margin: 0;
        color: var(--brand-slate);
        max-width: 70%;
      }

      .theme-ink .subtitle {
        color: rgba(247, 241, 232, 0.8);
      }

      .chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
      }

      .chip {
        padding: 8px 14px;
        border-radius: 999px;
        border: 1px solid var(--brand-line);
        font-size: 0.85rem;
        font-weight: 500;
        background: rgba(255, 255, 255, 0.6);
      }

      .theme-ink .chip {
        background: rgba(255, 255, 255, 0.06);
      }

      .section-title {
        font-family: var(--font-display);
        font-size: clamp(2rem, 3.4vw, 3rem);
        margin: 0;
      }

      .body-text {
        font-size: 1.05rem;
        line-height: 1.6;
        color: var(--brand-slate);
      }

      .theme-ink .body-text {
        color: rgba(247, 241, 232, 0.78);
      }

      .card {
        border-radius: 18px;
        border: 1px solid var(--brand-line);
        padding: 18px;
        background: rgba(255, 255, 255, 0.6);
        display: grid;
        gap: 10px;
      }

      .theme-ink .card {
        background: rgba(255, 255, 255, 0.04);
      }

      .card-title {
        font-weight: 600;
        font-size: 1rem;
      }

      .card-caption {
        font-size: 0.9rem;
        color: var(--brand-slate);
      }

      .theme-ink .card-caption {
        color: rgba(247, 241, 232, 0.72);
      }

      .metric {
        border: 1px solid var(--brand-line);
        border-radius: 18px;
        padding: 18px;
        text-align: left;
        background: rgba(255, 255, 255, 0.65);
      }

      .metric-number {
        font-family: var(--font-display);
        font-size: 2.4rem;
        margin-bottom: 8px;
      }

      .metric-label {
        font-size: 0.9rem;
        color: var(--brand-slate);
      }

      .media-frame {
        border-radius: 22px;
        border: 1px solid var(--brand-line);
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.2));
        padding: 14px;
        min-height: 320px;
        display: grid;
        place-items: center;
        position: relative;
        overflow: hidden;
      }

      .theme-ink .media-frame {
        background: rgba(255, 255, 255, 0.05);
      }

      .media-placeholder {
        text-align: center;
        font-size: 0.9rem;
        color: var(--brand-slate);
        padding: 16px;
        z-index: 2;
      }

      .media-frame[data-ready="true"] .media-placeholder {
        opacity: 0;
      }

      .gen-media {
        width: 100%;
        height: 100%;
        border-radius: 16px;
        object-fit: cover;
        opacity: 0;
        transition: opacity 0.4s ease;
      }

      .media-frame[data-ready="true"] .gen-media {
        opacity: 1;
      }

      .media-frame video.gen-media {
        background: #0b0f14;
      }

      .diagram {
        width: 100%;
        height: 100%;
      }

      .quote {
        font-family: var(--font-display);
        font-size: clamp(2rem, 3.6vw, 3.4rem);
        line-height: 1.2;
        margin: 0;
      }

      .quote-meta {
        margin-top: 16px;
        font-size: 0.95rem;
        color: var(--brand-slate);
      }

      .theme-ink .quote-meta {
        color: rgba(247, 241, 232, 0.7);
      }

      .swatch-row {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 16px;
      }

      .swatch {
        border-radius: 14px;
        padding: 14px;
        color: #ffffff;
        min-height: 80px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-size: 0.85rem;
      }

      .swatch span {
        font-weight: 600;
      }

      .deck-nav {
        position: fixed;
        bottom: 3vh;
        right: 4vw;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 14px;
        border-radius: 999px;
        background: rgba(13, 17, 23, 0.76);
        color: #f7f1e8;
        font-size: 0.9rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
      }

      .deck-nav button {
        border: none;
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        padding: 6px 10px;
        border-radius: 999px;
        cursor: pointer;
      }

      .deck-nav button:hover {
        background: rgba(255, 255, 255, 0.18);
      }

      .deck-nav .notes-toggle {
        background: rgba(255, 255, 255, 0.16);
        font-weight: 600;
      }

      .progress {
        width: 120px;
        height: 4px;
        background: rgba(255, 255, 255, 0.12);
        border-radius: 999px;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--brand-accent), var(--brand-sage));
        width: 0%;
      }

      .gen-toggle {
        position: fixed;
        bottom: 3vh;
        left: 4vw;
        border: none;
        border-radius: 999px;
        padding: 10px 16px;
        background: rgba(13, 17, 23, 0.76);
        color: #f7f1e8;
        font-size: 0.9rem;
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
      }

      .gen-panel {
        position: fixed;
        left: 4vw;
        bottom: 9vh;
        width: min(360px, 92vw);
        background: rgba(13, 17, 23, 0.92);
        color: #f7f1e8;
        border-radius: 18px;
        padding: 16px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 20px 40px rgba(13, 17, 23, 0.4);
        display: none;
        gap: 12px;
      }

      .gen-panel.is-open {
        display: grid;
      }

      .gen-panel label {
        font-size: 0.8rem;
        display: grid;
        gap: 6px;
      }

      .gen-panel input,
      .gen-panel select {
        border-radius: 10px;
        border: none;
        padding: 8px 10px;
        font-size: 0.9rem;
      }

      .notes-panel {
        position: fixed;
        right: 4vw;
        bottom: 9vh;
        width: min(360px, 92vw);
        background: rgba(13, 17, 23, 0.92);
        color: #f7f1e8;
        border-radius: 18px;
        padding: 16px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 20px 40px rgba(13, 17, 23, 0.4);
        display: none;
        gap: 12px;
      }

      .notes-panel.is-open {
        display: grid;
      }

      .notes-title {
        font-size: 0.85rem;
        color: rgba(247, 241, 232, 0.68);
      }

      .notes-body {
        font-size: 0.95rem;
        line-height: 1.5;
        white-space: pre-wrap;
        background: rgba(255, 255, 255, 0.08);
        padding: 12px;
        border-radius: 12px;
        max-height: 240px;
        overflow: auto;
      }

      .notes-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .notes-actions button {
        border: none;
        padding: 8px 12px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.12);
        color: inherit;
        cursor: pointer;
      }

      .gen-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .gen-actions button {
        border: none;
        padding: 8px 12px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.12);
        color: inherit;
        cursor: pointer;
      }

      .gen-status {
        font-size: 0.8rem;
        color: rgba(247, 241, 232, 0.72);
        min-height: 1.1em;
      }

      [data-anim] {
        opacity: 0;
        transition: opacity 0.5s ease, transform 0.5s ease;
        transition-delay: var(--anim-delay, 0s);
      }

      [data-anim="fade"] {
        transform: none;
      }

      [data-anim="slide-up"] {
        transform: translateY(18px);
      }

      [data-anim="slide-left"] {
        transform: translateX(18px);
      }

      [data-anim="slide-right"] {
        transform: translateX(-18px);
      }

      [data-anim="scale-in"] {
        transform: scale(0.96);
      }

      .slide.is-active [data-anim] {
        opacity: 1;
      }

      .slide.is-active [data-anim="fade"] {
        transform: none;
      }

      .slide.is-active [data-anim="slide-up"] {
        transform: translateY(0);
      }

      .slide.is-active [data-anim="slide-left"] {
        transform: translateX(0);
      }

      .slide.is-active [data-anim="slide-right"] {
        transform: translateX(0);
      }

      .slide.is-active [data-anim="scale-in"] {
        transform: scale(1);
      }

      .slide-notes {
        display: none;
      }

      .reveal {
        opacity: 0;
        transform: translateY(12px);
        transition: opacity 0.5s ease, transform 0.5s ease;
        transition-delay: calc(var(--reveal-index, 0) * 0.08s);
      }

      .slide.is-active .reveal {
        opacity: 1;
        transform: translateY(0);
      }

      @media (max-width: 900px) {
        .deck {
          height: min(640px, 76vh);
        }

        .layout-split {
          grid-template-columns: 1fr;
        }

        .layout-grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .layout-metrics {
          grid-template-columns: 1fr;
        }

        .subtitle {
          max-width: 100%;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .slide,
        .reveal,
        [data-anim] {
          transition: none;
          transform: none;
          opacity: 1;
        }
      }

      body[data-motion="off"] .reveal,
      body[data-motion="off"] [data-anim] {
        transition: none;
        transform: none;
        opacity: 1;
      }

      @page {
        size: 13.33in 7.5in;
        margin: 0.35in;
      }

      @media print {
        body {
          background: #ffffff;
          padding: 0;
          -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
        }

        .deck {
          width: 100%;
          height: auto;
        }

        .slide {
          position: relative;
          opacity: 1;
          transform: none;
          pointer-events: auto;
          page-break-after: always;
          break-after: page;
        }

        .slide:last-child {
          page-break-after: auto;
          break-after: auto;
        }

        .slide-inner {
          border-radius: 0;
          box-shadow: none;
        }

        .reveal,
        [data-anim] {
          opacity: 1;
          transform: none;
          transition: none;
        }

        .deck-nav,
        .gen-toggle,
        .gen-panel,
        .notes-panel,
        .review-toggle,
        .comment-sidebar,
        .comment-popover,
        .identity-modal {
          display: none;
        }
      }

      /* Review Mode Styles */
      body.review-mode .slide-inner {
        cursor: crosshair;
      }

      body.review-mode .commentable {
        position: relative;
        cursor: pointer;
        transition: outline 0.15s ease, background 0.15s ease;
      }

      body.review-mode .commentable:hover {
        outline: 2px solid var(--brand-accent);
        outline-offset: 4px;
        background: rgba(255, 107, 53, 0.08);
      }

      body.review-mode .commentable.has-comments {
        outline: 2px dashed var(--brand-sage);
        outline-offset: 2px;
      }

      body.review-mode .commentable.has-comments:hover {
        outline: 2px solid var(--brand-accent);
      }

      .comment-indicator {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--brand-accent);
        color: #fff;
        font-size: 0.7rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        z-index: 10;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      }

      .review-toggle {
        position: fixed;
        bottom: 3vh;
        left: calc(4vw + 60px);
        border: none;
        border-radius: 999px;
        padding: 10px 16px;
        background: rgba(13, 17, 23, 0.76);
        color: #f7f1e8;
        font-size: 0.9rem;
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
      }

      .review-toggle.is-active {
        background: var(--brand-accent);
        color: #fff;
      }

      .identity-modal {
        position: fixed;
        inset: 0;
        background: rgba(13, 17, 23, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        backdrop-filter: blur(4px);
      }

      .identity-modal.is-open {
        display: flex;
      }

      .identity-modal-inner {
        background: var(--brand-paper);
        border-radius: 18px;
        padding: 24px;
        width: min(400px, 90vw);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      .identity-modal h3 {
        margin: 0 0 16px;
        font-family: var(--font-display);
        font-size: 1.4rem;
      }

      .identity-modal label {
        display: block;
        margin-bottom: 12px;
        font-size: 0.9rem;
      }

      .identity-modal input {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--brand-line);
        font-size: 0.95rem;
        margin-top: 4px;
      }

      .identity-modal-actions {
        display: flex;
        gap: 8px;
        margin-top: 16px;
      }

      .identity-modal-actions button {
        flex: 1;
        padding: 10px 16px;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        font-size: 0.9rem;
      }

      .identity-modal-actions .btn-primary {
        background: var(--brand-accent);
        color: #fff;
      }

      .identity-modal-actions .btn-secondary {
        background: rgba(13, 17, 23, 0.08);
        color: var(--brand-ink);
      }

      .comment-popover {
        position: fixed;
        background: var(--brand-paper);
        border-radius: 14px;
        padding: 16px;
        width: min(320px, 85vw);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
        border: 1px solid var(--brand-line);
        z-index: 100;
        display: none;
      }

      .comment-popover.is-open {
        display: block;
      }

      .comment-popover-header {
        font-size: 0.8rem;
        color: var(--brand-slate);
        margin-bottom: 8px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .comment-popover textarea {
        width: 100%;
        min-height: 80px;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid var(--brand-line);
        font-size: 0.9rem;
        font-family: var(--font-body);
        resize: vertical;
      }

      .comment-popover-actions {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }

      .comment-popover-actions button {
        flex: 1;
        padding: 8px 12px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-size: 0.85rem;
      }

      .comment-popover-actions .btn-submit {
        background: var(--brand-accent);
        color: #fff;
      }

      .comment-popover-actions .btn-cancel {
        background: rgba(13, 17, 23, 0.08);
        color: var(--brand-ink);
      }

      .comment-sidebar {
        position: fixed;
        top: 0;
        right: 0;
        width: min(380px, 100vw);
        height: 100vh;
        background: rgba(13, 17, 23, 0.95);
        color: #f7f1e8;
        padding: 20px;
        overflow-y: auto;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        z-index: 90;
        border-left: 1px solid rgba(255, 255, 255, 0.1);
      }

      .comment-sidebar.is-open {
        transform: translateX(0);
      }

      .comment-sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .comment-sidebar-header h3 {
        margin: 0;
        font-size: 1.1rem;
      }

      .comment-sidebar-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 1.4rem;
        cursor: pointer;
        padding: 4px 8px;
      }

      .comment-sidebar-actions {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
      }

      .comment-sidebar-actions button {
        flex: 1;
        padding: 8px 12px;
        border-radius: 8px;
        border: none;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        cursor: pointer;
        font-size: 0.85rem;
      }

      .comment-sidebar-actions button:hover {
        background: rgba(255, 255, 255, 0.18);
      }

      .comment-list-empty {
        text-align: center;
        padding: 32px 16px;
        color: rgba(247, 241, 232, 0.6);
        font-size: 0.9rem;
      }

      .comment-item {
        background: rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        padding: 14px;
        margin-bottom: 12px;
      }

      .comment-item.is-resolved {
        opacity: 0.5;
      }

      .comment-item-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 8px;
      }

      .comment-item-author {
        font-weight: 600;
        font-size: 0.9rem;
      }

      .comment-item-time {
        font-size: 0.75rem;
        color: rgba(247, 241, 232, 0.5);
      }

      .comment-item-context {
        font-size: 0.8rem;
        color: var(--brand-accent);
        margin-bottom: 6px;
        font-style: italic;
      }

      .comment-item-text {
        font-size: 0.9rem;
        line-height: 1.5;
      }

      .comment-item-actions {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }

      .comment-item-actions button {
        padding: 4px 10px;
        border-radius: 6px;
        border: none;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        cursor: pointer;
        font-size: 0.75rem;
      }

      .comment-item-actions button:hover {
        background: rgba(255, 255, 255, 0.18);
      }

      .sidebar-toggle {
        position: fixed;
        top: 50%;
        right: 0;
        transform: translateY(-50%);
        background: rgba(13, 17, 23, 0.76);
        color: #f7f1e8;
        border: none;
        border-radius: 8px 0 0 8px;
        padding: 12px 8px;
        cursor: pointer;
        font-size: 0.8rem;
        writing-mode: vertical-rl;
        text-orientation: mixed;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-right: none;
        display: none;
        z-index: 85;
      }

      body.review-mode .sidebar-toggle {
        display: block;
      }

      .sidebar-toggle .comment-count {
        display: inline-block;
        background: var(--brand-accent);
        border-radius: 50%;
        width: 18px;
        height: 18px;
        font-size: 0.7rem;
        line-height: 18px;
        text-align: center;
        margin-top: 6px;
        writing-mode: horizontal-tb;
      }
    </style>
  </head>
  <body>
    <main class="deck" id="deck" aria-live="polite">
      <!-- Slide 1: HOOK (Change) -->
      <section class="slide theme-ink is-active" data-title="AI Shift">
        <div class="slide-inner layout-title">
          <div class="eyebrow" data-anim="slide-up" style="--anim-delay: 0.05s">The Shift</div>
          <h1 class="title" data-anim="slide-up" style="--anim-delay: 0.15s">AI flipped what presentations demand</h1>
          <p class="subtitle" data-anim="fade" style="--anim-delay: 0.25s">
            Not design skills. Prompting skills. The tools that dominated for decades now feel like drawing with a mouse.
          </p>
        </div>
        <aside class="slide-notes">
Open with the disruption. Pause after "AI flipped" to let it land.

The key tension: PowerPoint and Keynote ruled for 30 years because design skills were the bottleneck. Now the bottleneck is knowing what to ask for.

If presenting to skeptics, acknowledge that AI hype is real—but this is about workflow, not magic.
        </aside>
      </section>

      <!-- Slide 2: STAKES (The Cost) -->
      <section class="slide theme-ivory" data-title="The Cost">
        <div class="slide-inner layout-split">
          <div>
            <div class="eyebrow reveal" data-anim="fade" style="--reveal-index: 1; --anim-delay: 0.05s">The Cost</div>
            <h2 class="section-title reveal" data-anim="slide-left" style="--reveal-index: 2; --anim-delay: 0.1s">Eight hours vanish into formatting—not thinking</h2>
            <p class="body-text reveal" data-anim="fade" style="--reveal-index: 3; --anim-delay: 0.15s">
              The average professional spends a full workday on each deck. Most of that time? Alignment, colors, exports. The story gets whatever's left.
            </p>
          </div>
          <div class="media-frame reveal" data-anim="slide-right" style="--reveal-index: 2; --anim-delay: 0.1s" data-ready="true">
            <img class="gen-media" src="resources/assets/workflow-diagram.png" alt="Time lost to formatting visualized" style="opacity: 1;" />
          </div>
        </div>
        <aside class="slide-notes">
This is the pain point everyone recognizes. Ask the audience: "How many hours did your last deck take?"

The 8-hour stat comes from internal surveys at consulting firms. Adjust if you have your own data.

Point to the visual: most of that time is mechanical—alignment, color matching, exporting assets. The actual thinking gets compressed into whatever time remains.
        </aside>
      </section>

      <!-- Slide 3: CONTRAST (Winners) -->
      <section class="slide theme-ivory" data-title="Early Adopters">
        <div class="slide-inner layout-split">
          <div>
            <div class="eyebrow reveal" data-anim="fade" style="--reveal-index: 1; --anim-delay: 0.05s">The Contrast</div>
            <h2 class="section-title reveal" data-anim="slide-left" style="--reveal-index: 2; --anim-delay: 0.1s">Early adopters ship decks in minutes</h2>
            <p class="body-text reveal" data-anim="fade" style="--reveal-index: 3; --anim-delay: 0.15s">
              Same quality. Fraction of time. They stopped fighting tools and started describing what they need.
            </p>
            <div class="chip-row reveal" data-anim="slide-up" style="--reveal-index: 4; --anim-delay: 0.2s">
              <div class="chip">Describe</div>
              <div class="chip">Generate</div>
              <div class="chip">Ship</div>
            </div>
          </div>
          <div class="media-frame reveal" data-anim="slide-right" style="--reveal-index: 2; --anim-delay: 0.1s" data-ready="true">
            <img class="gen-media" src="resources/assets/cli-workflow.png" alt="Clean prompt interface vs cluttered toolbar" style="opacity: 1;" />
          </div>
        </div>
        <aside class="slide-notes">
Contrast slide: set up the "haves vs have-nots" dynamic.

Emphasize the three-step workflow: Describe, Generate, Ship. This becomes a refrain—repeat it in the CTA.

The visual shows the difference: cluttered toolbars vs. a clean prompt interface. Let the image make the argument.
        </aside>
      </section>

      <!-- Slide 4: PROMISED LAND -->
      <section class="slide theme-ink" data-title="Promised Land">
        <div class="slide-inner layout-title">
          <div class="eyebrow" data-anim="fade" style="--anim-delay: 0.05s">The Destination</div>
          <h1 class="title" data-anim="slide-up" style="--anim-delay: 0.15s">One file. AI visuals. Brand-perfect.</h1>
          <p class="subtitle" data-anim="fade" style="--anim-delay: 0.35s">
            Describe your diagram. Watch it appear. Switch brands with a URL parameter. Export to PDF. Ship.
          </p>
        </div>
        <aside class="slide-notes">
This is the promise slide. Slow down and let each phrase land:
- "One file" = portability, no dependency hell
- "AI visuals" = no more stock photo hunting or Illustrator
- "Brand-perfect" = consistency without a design system degree

The dark theme signals a shift—we're moving from problem to solution. Everything after this is "how."
        </aside>
      </section>

      <!-- Slide 5: GIFT 1 (Text-to-Image) -->
      <section class="slide theme-ivory" data-title="AI Generation">
        <div class="slide-inner layout-split">
          <div>
            <div class="eyebrow" data-anim="fade" style="--anim-delay: 0.05s">Capability</div>
            <h2 class="section-title" data-anim="slide-up" style="--anim-delay: 0.1s">Gemini generates infographics while you outline</h2>
            <p class="body-text" data-anim="fade" style="--anim-delay: 0.2s">
              Add a prompt to any image tag. Press G. Diagrams, charts, and illustrations materialize in your brand's colors.
            </p>
            <div class="card" data-anim="slide-up" style="--anim-delay: 0.3s">
              <div class="card-title">Example prompt</div>
              <div class="card-caption" style="font-family: monospace; font-size: 0.85rem;">data-prompt="Flowchart: brief to ship"</div>
            </div>
          </div>
          <div class="media-frame" data-anim="scale-in" style="--anim-delay: 0.15s" data-ready="true">
            <img class="gen-media" src="resources/assets/text-to-image-demo.png" alt="Generated infographic example" style="opacity: 1;" />
          </div>
        </div>
        <aside class="slide-notes">
First capability: AI image generation. This is the "wow" moment for most audiences.

Demo opportunity: If presenting live, press G to open the generator panel and show the workflow. Generate something simple like a flowchart.

Key point: The prompt includes brand context automatically—you don't have to specify colors every time.
        </aside>
      </section>

      <!-- Slide 6: GIFT 2 (Brand System) -->
      <section class="slide theme-ivory" data-title="Brand System">
        <div class="slide-inner layout-split" style="grid-template-columns: 0.9fr 1.1fr;">
          <div class="media-frame" data-anim="slide-right" style="--anim-delay: 0.1s" data-ready="true">
            <img class="gen-media" src="resources/assets/brand-system.png" alt="Three brand treatments of the same content" style="opacity: 1;" />
          </div>
          <div>
            <div class="eyebrow" data-anim="fade" style="--anim-delay: 0.05s">Capability</div>
            <h2 class="section-title" data-anim="slide-left" style="--anim-delay: 0.15s">One template adapts to any brand in seconds</h2>
            <p class="body-text" data-anim="fade" style="--anim-delay: 0.25s">
              Three identities ship in the box. Add yours in brands.js. Switch with a URL parameter.
            </p>
            <div class="card" data-anim="slide-up" style="--anim-delay: 0.35s">
              <div class="card-caption" style="font-family: monospace;">?entity=northwind</div>
              <div class="card-caption" style="font-family: monospace;">?entity=apex</div>
              <div class="card-caption" style="font-family: monospace;">?entity=coastal</div>
            </div>
          </div>
        </div>
        <aside class="slide-notes">
Second capability: Multi-brand theming.

Demo opportunity: Add ?entity=apex to the URL and watch the whole deck transform. Great for agencies or consultants who serve multiple clients.

The image shows the same content in three brand treatments. Point out: colors, typography, and even the AI prompt prefixes change automatically.
        </aside>
      </section>

      <!-- Slide 7: GIFT 3 (Narrative Engine) -->
      <section class="slide theme-ivory" data-title="Narrative Engine">
        <div class="slide-inner layout-split">
          <div>
            <div class="eyebrow" data-anim="fade" style="--anim-delay: 0.05s">Capability</div>
            <h2 class="section-title" data-anim="slide-up" style="--anim-delay: 0.1s">Seventeen frameworks structure your story</h2>
            <p class="body-text" data-anim="fade" style="--anim-delay: 0.2s">
              Answer five questions. Get matched to The Prestige, The Heist, Hero's Journey—whichever fits your content.
            </p>
            <div class="chip-row" data-anim="slide-up" style="--anim-delay: 0.3s">
              <div class="chip">Audience</div>
              <div class="chip">Purpose</div>
              <div class="chip">Content</div>
              <div class="chip">Tone</div>
              <div class="chip">Reveal</div>
            </div>
          </div>
          <div class="media-frame" data-anim="scale-in" style="--anim-delay: 0.15s" data-ready="true">
            <img class="gen-media" src="resources/assets/template-preview.png" alt="Framework selection flowchart" style="opacity: 1;" />
          </div>
        </div>
        <aside class="slide-notes">
Third capability: Narrative Engine from Noah Raford's framework library.

The five questions: Audience, Purpose, Content type, Tone, and Reveal structure. Based on answers, the system recommends frameworks like:
- The Prestige (surprise ending)
- The Heist (strategic roadmap)
- Hero's Journey (transformation story)

This deck uses a modified "Gift" structure—problem, promise, then capabilities as gifts.
        </aside>
      </section>

      <!-- Slide 8: GIFT 4 (Review Panel) -->
      <section class="slide theme-ink" data-title="Review Panel">
        <div class="slide-inner layout-title">
          <div class="eyebrow reveal" data-anim="fade" style="--reveal-index: 1; --anim-delay: 0.05s">Capability</div>
          <h1 class="title reveal" data-anim="slide-up" style="--reveal-index: 2; --anim-delay: 0.1s">Five agents challenge every claim before you present</h1>
          <p class="subtitle reveal" data-anim="fade" style="--reveal-index: 3; --anim-delay: 0.2s">
            Audience Advocate. Comms Specialist. Visual Designer. Critic. Content Expert. They argue. You get prioritized fixes.
          </p>
        </div>
        <aside class="slide-notes">
Fourth capability: AI review panel. This is the "antagonistic agents" system.

Walk through each agent briefly:
- Audience Advocate: "Does this land for YOUR specific audience?"
- Comms Specialist: "Is the headline bulletproof?"
- Visual Designer: "What visual makes this unforgettable?"
- Critic: "What's the weakest slide? Cut it."
- Content Expert: "Can you defend every claim?"

They debate. You get a prioritized fix list. Much faster than waiting for human reviewers.
        </aside>
      </section>

      <!-- Slide 9: GIFT 5 (Review Mode) -->
      <section class="slide theme-ivory" data-title="Review Mode">
        <div class="slide-inner layout-split">
          <div>
            <div class="eyebrow reveal" data-anim="fade" style="--reveal-index: 1; --anim-delay: 0.05s">Capability</div>
            <h2 class="section-title reveal" data-anim="slide-left" style="--reveal-index: 2; --anim-delay: 0.1s">Reviewers leave feedback directly on your slides</h2>
            <p class="body-text reveal" data-anim="fade" style="--reveal-index: 3; --anim-delay: 0.15s">
              Share the URL. They press R to enter review mode, click any element, and leave comments. Export to JSON or markdown.
            </p>
            <div class="chip-row reveal" data-anim="slide-up" style="--reveal-index: 4; --anim-delay: 0.2s">
              <div class="chip">Press R</div>
              <div class="chip">Click element</div>
              <div class="chip">Add feedback</div>
              <div class="chip">Export</div>
            </div>
          </div>
          <div class="media-frame reveal" data-anim="slide-right" style="--reveal-index: 2; --anim-delay: 0.1s">
            <div class="media-placeholder">Review mode interface mockup</div>
            <img
              class="gen-media"
              data-media="gemini"
              data-gen="text-to-image"
              data-prompt="Clean UI mockup showing a slide deck with review mode active: an element highlighted with an orange border, a comment popover with a text field and submit button, and a small badge showing comment count. Minimal, warm parchment palette, flat design, 16:9 aspect ratio."
              alt="Review mode interface"
            />
          </div>
        </div>
        <aside class="slide-notes">
Fifth capability: Human review mode. Complements the AI review panel.

Demo opportunity: Press R right now to show review mode. Click on any element to show the comment popover. Press C to show the sidebar.

Key workflow: Share URL → reviewer presses R → clicks elements → leaves comments → you export JSON or markdown for iteration.

Comments persist in localStorage. Export to share or feed back to Claude for revisions.
        </aside>
      </section>

      <!-- Slide 10: PROOF (Metrics) -->
      <section class="slide theme-ivory" data-title="Proof">
        <div class="slide-inner layout-metrics">
          <div class="metric reveal" data-anim="scale-in" style="--reveal-index: 1; --anim-delay: 0.1s">
            <div class="metric-number">12 min</div>
            <div class="metric-label">Build time for this deck</div>
          </div>
          <div class="metric reveal" data-anim="scale-in" style="--reveal-index: 2; --anim-delay: 0.2s">
            <div class="metric-number">11 slides</div>
            <div class="metric-label">Framework-structured narrative</div>
          </div>
          <div class="metric reveal" data-anim="scale-in" style="--reveal-index: 3; --anim-delay: 0.3s">
            <div class="metric-number">1 file</div>
            <div class="metric-label">Portable HTML output</div>
          </div>
        </div>
        <aside class="slide-notes">
Proof slide: Make it concrete with numbers.

- 12 minutes: From brief to finished deck. Compare to the 8 hours on slide 2.
- 11 slides: Not a toy example—a real narrative arc with framework structure.
- 1 file: No dependencies, no build step. Open in any browser, share via URL, print to PDF.

Pause here. Let the contrast with the "8 hours" from earlier sink in.
        </aside>
      </section>

      <!-- Slide 11: CTA -->
      <section class="slide theme-ink" data-title="Call to Action">
        <div class="slide-inner layout-title">
          <div class="eyebrow reveal" data-anim="fade" style="--reveal-index: 1; --anim-delay: 0.05s">Start Now</div>
          <h1 class="title reveal" data-anim="slide-up" style="--reveal-index: 2; --anim-delay: 0.1s">Your next deck starts with a brief, not a blank slide</h1>
          <p class="subtitle reveal" data-anim="fade" style="--reveal-index: 3; --anim-delay: 0.2s">
            Clone the repo. Drop your materials in resources/. Let the skill do the rest.
          </p>
          <div class="chip-row reveal" data-anim="slide-up" style="--reveal-index: 4; --anim-delay: 0.25s">
            <div class="chip">Clone</div>
            <div class="chip">Brief</div>
            <div class="chip">Ship</div>
          </div>
        </div>
        <aside class="slide-notes">
Close with a clear call to action. Echo the "Describe, Generate, Ship" from slide 3, now as "Clone, Brief, Ship."

The key reframe: You don't start with a blank slide anymore. You start with a brief—your raw materials, your messy notes, your half-formed ideas. The skill structures and visualizes.

If Q&A follows: Be ready for "What about [PowerPoint/Keynote/Canva]?" Answer: Those are design tools. This is a thinking tool that happens to output slides.

Thank you. Questions?
        </aside>
      </section>
    </main>

    <nav class="deck-nav" aria-label="Slide navigation">
      <button id="prev-btn" type="button" aria-label="Previous slide">&larr;</button>
      <div class="progress" aria-hidden="true">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
      <div id="progress-count">1 / 11</div>
      <button class="notes-toggle" id="notes-toggle" type="button">Notes</button>
      <button id="next-btn" type="button" aria-label="Next slide">&rarr;</button>
    </nav>

    <aside class="notes-panel" id="notes-panel" aria-hidden="true">
      <strong>Speaker Notes</strong>
      <div class="notes-title" id="notes-title">Slide notes</div>
      <div class="notes-body" id="notes-body">No notes yet.</div>
      <div class="notes-actions">
        <button id="notes-export" type="button">Export notes</button>
        <button id="notes-close" type="button">Close</button>
      </div>
    </aside>

    <button class="gen-toggle" id="gen-toggle" type="button">Gen</button>
    <button class="review-toggle" id="review-toggle" type="button">Review</button>
    <button class="sidebar-toggle" id="sidebar-toggle" type="button">
      Comments <span class="comment-count" id="sidebar-count">0</span>
    </button>
    <aside class="gen-panel" id="gen-panel" aria-hidden="true">
      <strong>Gemini Media Controls</strong>
      <label>
        API key (local only)
        <input id="gen-key" type="password" placeholder="GEMINI_API_KEY" />
      </label>
      <label>
        Entity profile
        <select id="gen-entity"></select>
      </label>
      <label>
        Image model (nano banana)
        <input id="gen-image-model" type="text" inputmode="text" placeholder="gemini-2.5-flash-image" />
      </label>
      <label>
        Base image (optional for i2i/i2v)
        <input id="gen-base" type="file" accept="image/*" />
      </label>
      <label>
        Video model
        <select id="gen-video-model">
          <option value="veo-3.1-generate-preview">veo-3.1-generate-preview</option>
          <option value="veo-3.0-generate-preview">veo-3.0-generate-preview</option>
        </select>
      </label>
      <div class="gen-actions">
        <button id="gen-save" type="button">Save settings</button>
        <button id="gen-slide" type="button">Generate slide</button>
        <button id="gen-all" type="button">Generate all</button>
        <button id="gen-close" type="button">Close</button>
      </div>
      <div class="gen-status" id="gen-status"></div>
    </aside>

    <template id="template-title">
      <section class="slide theme-ivory" data-title="Title">
        <div class="slide-inner layout-title">
          <div class="eyebrow">Eyebrow</div>
          <h1 class="title">Slide Title</h1>
          <p class="subtitle">Subtitle with a concise thesis.</p>
          <div class="chip-row">
            <div class="chip">Chip one</div>
            <div class="chip">Chip two</div>
          </div>
        </div>
      </section>
    </template>

    <template id="template-split">
      <section class="slide theme-ivory" data-title="Split">
        <div class="slide-inner layout-split">
          <div>
            <h2 class="section-title">Section title</h2>
            <p class="body-text">Narrative text goes here.</p>
          </div>
          <div class="media-frame">
            <div class="media-placeholder">Media</div>
          </div>
        </div>
      </section>
    </template>

    <template id="template-metrics">
      <section class="slide theme-ivory" data-title="Metrics">
        <div class="slide-inner layout-metrics">
          <div class="metric">
            <div class="metric-number">45%</div>
            <div class="metric-label">Metric label</div>
          </div>
          <div class="metric">
            <div class="metric-number">3.2x</div>
            <div class="metric-label">Metric label</div>
          </div>
          <div class="metric">
            <div class="metric-number">12</div>
            <div class="metric-label">Metric label</div>
          </div>
        </div>
      </section>
    </template>

    <template id="template-quote">
      <section class="slide theme-ink" data-title="Quote">
        <div class="slide-inner layout-quote">
          <p class="quote">"Quote goes here."</p>
          <div class="quote-meta">Source</div>
        </div>
      </section>
    </template>

    <!-- Identity Modal -->
    <div class="identity-modal" id="identity-modal" aria-hidden="true">
      <div class="identity-modal-inner">
        <h3>Enter your details</h3>
        <p style="font-size: 0.9rem; color: var(--brand-slate); margin-bottom: 16px;">
          Your name and email will be attached to comments.
        </p>
        <label>
          Name
          <input type="text" id="identity-name" placeholder="Your name" />
        </label>
        <label>
          Email
          <input type="email" id="identity-email" placeholder="you@example.com" />
        </label>
        <div class="identity-modal-actions">
          <button type="button" class="btn-secondary" id="identity-cancel">Cancel</button>
          <button type="button" class="btn-primary" id="identity-save">Continue</button>
        </div>
      </div>
    </div>

    <!-- Comment Popover -->
    <div class="comment-popover" id="comment-popover">
      <div class="comment-popover-header" id="popover-context">Element context</div>
      <textarea id="comment-text" placeholder="Enter your feedback..."></textarea>
      <div class="comment-popover-actions">
        <button type="button" class="btn-cancel" id="popover-cancel">Cancel</button>
        <button type="button" class="btn-submit" id="popover-submit">Add Comment</button>
      </div>
    </div>

    <!-- Comment Sidebar -->
    <aside class="comment-sidebar" id="comment-sidebar" aria-hidden="true">
      <div class="comment-sidebar-header">
        <h3>Comments</h3>
        <button class="comment-sidebar-close" id="sidebar-close" type="button">&times;</button>
      </div>
      <div class="comment-sidebar-actions">
        <button type="button" id="export-comments">Export JSON</button>
        <button type="button" id="export-markdown">Export MD</button>
      </div>
      <div id="comment-list"></div>
    </aside>

    <template id="template-diagram">
      <section class="slide theme-ivory" data-title="Diagram">
        <div class="slide-inner layout-split">
          <div>
            <h2 class="section-title">Diagram title</h2>
            <p class="body-text">Explain the diagram in one line.</p>
          </div>
          <div class="media-frame" data-media="svg">
            <svg class="diagram" data-media="svg" viewBox="0 0 800 450" role="img" aria-label="Diagram placeholder">
              <rect width="800" height="450" rx="24" fill="rgba(15, 23, 42, 0.08)" />
              <rect x="60" y="80" width="260" height="80" rx="16" fill="rgba(255, 107, 53, 0.2)" />
              <rect x="480" y="280" width="260" height="80" rx="16" fill="rgba(147, 167, 122, 0.2)" />
              <line x1="320" y1="120" x2="480" y2="320" stroke="rgba(15, 23, 42, 0.35)" stroke-width="3" />
              <text x="190" y="130" text-anchor="middle" fill="rgba(15, 23, 42, 0.8)" font-size="18">Input</text>
              <text x="610" y="330" text-anchor="middle" fill="rgba(15, 23, 42, 0.8)" font-size="18">Output</text>
            </svg>
          </div>
        </div>
      </section>
    </template>

    <script src="../brands.js"></script>
    <script src="./deck-config.js"></script>
    <script>
      const slides = Array.from(document.querySelectorAll(".slide"));
      const progressBar = document.getElementById("progress-bar");
      const progressCount = document.getElementById("progress-count");
      const prevBtn = document.getElementById("prev-btn");
      const nextBtn = document.getElementById("next-btn");
      const notesToggle = document.getElementById("notes-toggle");
      const notesPanel = document.getElementById("notes-panel");
      const notesTitle = document.getElementById("notes-title");
      const notesBody = document.getElementById("notes-body");
      const notesClose = document.getElementById("notes-close");
      const notesExport = document.getElementById("notes-export");
      let currentIndex = slides.findIndex((slide) => slide.classList.contains("is-active"));
      if (currentIndex < 0 && slides.length) {
        currentIndex = 0;
        slides[0].classList.add("is-active");
      }

      const genToggle = document.getElementById("gen-toggle");
      const genPanel = document.getElementById("gen-panel");
      const genKey = document.getElementById("gen-key");
      const genBase = document.getElementById("gen-base");
      const genSave = document.getElementById("gen-save");
      const genSlide = document.getElementById("gen-slide");
      const genAll = document.getElementById("gen-all");
      const genClose = document.getElementById("gen-close");
      const genStatus = document.getElementById("gen-status");
      const genEntity = document.getElementById("gen-entity");
      const genImageModel = document.getElementById("gen-image-model");
      const genVideoModel = document.getElementById("gen-video-model");

      const apiBase = "https://generativelanguage.googleapis.com/v1beta";
      const defaultImageModel = "gemini-2.5-flash-image";
      const keyStorage = "GEMINI_API_KEY";
      const imageModelStorage = "KEYNOTE_IMAGE_MODEL";
      const deckConfig = window.KEYNOTE_DECK || {};
      const deckId =
        typeof deckConfig.id === "string" && deckConfig.id.trim()
          ? deckConfig.id.trim()
          : "default";
      const entityStorage = `KEYNOTE_ENTITY_${deckId}`;
      // Example brand profiles - replace with your own
      const fallbackBrandProfiles = {
        northwind: {
          label: "Northwind Labs",
          tokens: {
            "brand-ink": "#1a1a2e",
            "brand-ink-soft": "#2d2d44",
            "brand-paper": "#fafbfc",
            "brand-paper-deep": "#f0f2f5",
            "brand-accent": "#ed8936",
            "brand-accent-strong": "#dd6b20",
            "brand-sage": "#00b5d8",
            "brand-slate": "#4a5568",
            "brand-line": "rgba(26, 26, 46, 0.12)",
            "brand-glow": "rgba(237, 137, 54, 0.35)",
          },
          fonts: {
            display: "\"Inter\", \"Helvetica Neue\", sans-serif",
            body: "\"Inter\", \"Helvetica Neue\", sans-serif",
          },
          fontLabel: "Display: Inter. Body: Inter.",
          mediaPromptPrefix: "modern tech palette, amber and cyan highlights, clean studio lighting",
        },
        apex: {
          label: "Apex Consulting",
          tokens: {
            "brand-ink": "#1a1a1a",
            "brand-ink-soft": "#333333",
            "brand-paper": "#f5f1e8",
            "brand-paper-deep": "#e8dcc6",
            "brand-accent": "#b8956f",
            "brand-accent-strong": "#9a7a57",
            "brand-sage": "#d4a574",
            "brand-slate": "#666666",
            "brand-line": "rgba(26, 26, 26, 0.12)",
            "brand-glow": "rgba(184, 149, 111, 0.35)",
          },
          fonts: {
            display: "\"Helvetica Neue\", \"Segoe UI\", \"Helvetica\", sans-serif",
            body: "\"Helvetica Neue\", \"Segoe UI\", \"Helvetica\", sans-serif",
          },
          fontLabel: "Display: System sans. Body: System sans.",
          mediaPromptPrefix: "warm parchment palette, refined brass accents, minimal editorial lighting",
        },
        coastal: {
          label: "Coastal Biotech",
          tokens: {
            "brand-ink": "#0e2841",
            "brand-ink-soft": "#1a3a57",
            "brand-paper": "#f6f7f9",
            "brand-paper-deep": "#e8e8e8",
            "brand-accent": "#156082",
            "brand-accent-strong": "#0f9ed5",
            "brand-sage": "#196b24",
            "brand-slate": "#0e2841",
            "brand-line": "rgba(14, 40, 65, 0.12)",
            "brand-glow": "rgba(21, 96, 130, 0.32)",
          },
          fonts: {
            display: "\"Avenir Next\", \"Helvetica Neue\", sans-serif",
            body: "\"Avenir Next\", \"Helvetica Neue\", sans-serif",
          },
          fontLabel: "Display: Avenir Next. Body: Avenir Next.",
          mediaPromptPrefix: "navy biotech palette, teal accents, high-clarity lab lighting",
        },
      };
      let brandProfiles =
        window.KEYNOTE_BRANDS && typeof window.KEYNOTE_BRANDS === "object"
          ? window.KEYNOTE_BRANDS
          : fallbackBrandProfiles;
      const defaultEntity =
        typeof deckConfig.entity === "string" && deckConfig.entity.trim()
          ? deckConfig.entity.trim()
          : typeof window.KEYNOTE_DEFAULT_ENTITY === "string" && window.KEYNOTE_DEFAULT_ENTITY.trim()
            ? window.KEYNOTE_DEFAULT_ENTITY.trim()
            : "northwind";
      let currentEntity = defaultEntity;
      let baseImage = null;

      const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      const setStatus = (message) => {
        genStatus.textContent = message || "";
      };

      const resolveKey = () =>
        localStorage.getItem(keyStorage) ||
        localStorage.getItem("NANO_BANANA_API_KEY") ||
        "";

      const saveKey = (value) => {
        if (value) {
          localStorage.setItem(keyStorage, value);
        }
      };

      const resolveImageModel = () => {
        const fromInput = genImageModel?.value?.trim();
        return (
          fromInput ||
          localStorage.getItem("NANO_BANANA_IMAGE_MODEL") ||
          localStorage.getItem(imageModelStorage) ||
          defaultImageModel
        );
      };

      const saveImageModel = (value) => {
        if (value) {
          localStorage.setItem(imageModelStorage, value);
        }
      };

      const resolveEntity = () => {
        const params = new URLSearchParams(window.location.search);
        const fromQuery = params.get("entity");
        if (fromQuery) return fromQuery;
        const stored = localStorage.getItem(entityStorage);
        if (stored) return stored;
        return defaultEntity;
      };

      const updateTokenLabels = () => {
        document.querySelectorAll("[data-token]").forEach((el) => {
          const token = el.dataset.token;
          if (!token) return;
          const value = getComputedStyle(document.documentElement)
            .getPropertyValue(`--${token}`)
            .trim();
          if (value) el.textContent = value;
        });
      };

      const applyBrandProfile = (entityId, opts = {}) => {
        const profile = brandProfiles[entityId] || brandProfiles[defaultEntity];
        if (!profile) return;
        Object.entries(profile.tokens || {}).forEach(([token, value]) => {
          if (value) {
            document.documentElement.style.setProperty(`--${token}`, value);
          }
        });
        if (profile.fonts?.display) {
          document.documentElement.style.setProperty("--font-display", profile.fonts.display);
        }
        if (profile.fonts?.body) {
          document.documentElement.style.setProperty("--font-body", profile.fonts.body);
        }
        if (profile.fontLabel) {
          const label = document.querySelector("[data-font-label]");
          if (label) label.textContent = profile.fontLabel;
        }
        document.body.dataset.entity = entityId;
        updateTokenLabels();
        if (opts.persist) {
          currentEntity = entityId;
          localStorage.setItem(entityStorage, entityId);
        }
      };

      const applyEntityForSlide = (slide) => {
        const entityId = slide?.dataset?.entity || currentEntity;
        applyBrandProfile(entityId, { persist: false });
      };

      const resolveEntityForElement = (element) => {
        if (!element) return currentEntity;
        const elementEntity = element.dataset?.entity;
        if (elementEntity && brandProfiles[elementEntity]) return elementEntity;
        const slideEntity = element.closest(".slide")?.dataset?.entity;
        if (slideEntity && brandProfiles[slideEntity]) return slideEntity;
        return currentEntity;
      };

      const buildPrompt = (prompt, entityId) => {
        const profile = brandProfiles[entityId] || brandProfiles[currentEntity] || brandProfiles[defaultEntity];
        const prefix = profile?.mediaPromptPrefix || "";
        const suffix = profile?.mediaPromptSuffix || "";
        return [prefix, prompt, suffix].filter(Boolean).join(", ");
      };

      const populateEntitySelect = () => {
        if (!genEntity) return;
        genEntity.innerHTML = "";
        Object.entries(brandProfiles).forEach(([id, profile]) => {
          const option = document.createElement("option");
          option.value = id;
          option.textContent = profile.label || id;
          genEntity.appendChild(option);
        });
      };

      const normalizeNotes = (value) => {
        if (!value) return "";
        return value.replace(/\r\n/g, "\n").replace(/\\n/g, "\n").trim();
      };

      const getNotesForSlide = (slide) => {
        if (!slide) return "";
        const direct = slide.dataset?.notes;
        if (direct) return normalizeNotes(direct);
        const notesEl = slide.querySelector(".slide-notes, [data-notes]");
        if (!notesEl) return "";
        if (notesEl.dataset?.notes) return normalizeNotes(notesEl.dataset.notes);
        return normalizeNotes(notesEl.textContent || "");
      };

      const setNotesPanelOpen = (isOpen) => {
        if (!notesPanel) return;
        notesPanel.classList.toggle("is-open", isOpen);
        notesPanel.setAttribute("aria-hidden", String(!isOpen));
      };

      const updateNotesPanel = (slide, index = currentIndex) => {
        if (!notesPanel || !notesTitle || !notesBody) return;
        const title = slide?.dataset?.title || `Slide ${index + 1}`;
        const notes = getNotesForSlide(slide);
        notesTitle.textContent = `Slide ${index + 1}: ${title}`;
        notesBody.textContent = notes || "No notes yet.";
      };

      const exportNotes = () => {
        const entries = slides
          .map((slide, index) => ({
            index: index + 1,
            title: slide.dataset.title || `Slide ${index + 1}`,
            notes: getNotesForSlide(slide),
          }))
          .filter((entry) => entry.notes);

        if (!entries.length) {
          updateNotesPanel(slides[currentIndex], currentIndex);
          setNotesPanelOpen(true);
          return;
        }

        const deckTitle = (deckConfig.title || document.title || "Deck").trim();
        const lines = [`# Speaker Notes`, "", `Deck: ${deckTitle}`, ""];
        entries.forEach((entry) => {
          lines.push(`## Slide ${entry.index}: ${entry.title}`);
          lines.push("");
          lines.push(entry.notes);
          lines.push("");
        });

        const blob = new Blob([lines.join("\n")], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `speaker-notes-${deckId}.md`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      };

      const updateProgress = () => {
        const total = slides.length;
        const current = currentIndex + 1;
        const pct = total === 0 ? 0 : (current / total) * 100;
        progressBar.style.width = `${pct}%`;
        progressCount.textContent = `${current} / ${total}`;
      };

      const showSlide = (index) => {
        if (index < 0 || index >= slides.length) return;
        slides[currentIndex]?.classList.remove("is-active");
        slides[currentIndex]?.setAttribute("aria-hidden", "true");
        currentIndex = index;
        slides[currentIndex].classList.add("is-active");
        slides[currentIndex].setAttribute("aria-hidden", "false");
        updateProgress();
        applyEntityForSlide(slides[currentIndex]);
        updateNotesPanel(slides[currentIndex], currentIndex);
        const slug = slides[currentIndex].dataset.title || `slide-${currentIndex + 1}`;
        history.replaceState(null, "", `#${slug.toLowerCase().replace(/\\s+/g, "-")}`);
      };

      const nextSlide = () => showSlide(currentIndex + 1);
      const prevSlide = () => showSlide(currentIndex - 1);

      const gotoFromHash = () => {
        const hash = window.location.hash.replace("#", "").trim();
        if (!hash) return;
        const idx = slides.findIndex((slide) => {
          const title = slide.dataset.title || "";
          const slug = title.toLowerCase().replace(/\\s+/g, "-");
          return slug === hash;
        });
        if (idx >= 0) showSlide(idx);
      };

      prevBtn.addEventListener("click", prevSlide);
      nextBtn.addEventListener("click", nextSlide);
      const toggleNotesPanel = () => {
        if (!notesPanel) return;
        const shouldOpen = !notesPanel.classList.contains("is-open");
        updateNotesPanel(slides[currentIndex], currentIndex);
        setNotesPanelOpen(shouldOpen);
      };
      notesToggle?.addEventListener("click", toggleNotesPanel);
      notesClose?.addEventListener("click", () => setNotesPanelOpen(false));
      notesExport?.addEventListener("click", exportNotes);

      document.addEventListener("keydown", (event) => {
        const target = event.target;
        if (
          target &&
          (target.tagName === "INPUT" ||
            target.tagName === "TEXTAREA" ||
            target.tagName === "SELECT" ||
            target.isContentEditable)
        ) {
          return;
        }
        if (event.key === "ArrowRight" || event.key === "PageDown" || event.key === " ") {
          event.preventDefault();
          nextSlide();
        }
        if (event.key === "ArrowLeft" || event.key === "PageUp") {
          event.preventDefault();
          prevSlide();
        }
        if (event.key === "Home") {
          event.preventDefault();
          showSlide(0);
        }
        if (event.key === "End") {
          event.preventDefault();
          showSlide(slides.length - 1);
        }
        if (event.key.toLowerCase() === "g") {
          event.preventDefault();
          genPanel.classList.toggle("is-open");
          genPanel.setAttribute("aria-hidden", String(!genPanel.classList.contains("is-open")));
        }
        if (event.key.toLowerCase() === "n") {
          event.preventDefault();
          toggleNotesPanel();
        }
      });

      let touchStartX = 0;
      document.addEventListener("touchstart", (event) => {
        touchStartX = event.changedTouches[0].clientX;
      });
      document.addEventListener("touchend", (event) => {
        const deltaX = event.changedTouches[0].clientX - touchStartX;
        if (Math.abs(deltaX) < 50) return;
        if (deltaX < 0) nextSlide();
        if (deltaX > 0) prevSlide();
      });

      window.addEventListener("hashchange", gotoFromHash);

      const parseDataUrl = (dataUrl) => {
        const match = dataUrl.match(/^data:(.*?);base64,(.*)$/);
        if (!match) return null;
        return { mimeType: match[1], base64: match[2] };
      };

      const loadBaseImage = (file) =>
        new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onerror = () => reject(new Error("Failed to read base image"));
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(file);
        });

      genBase.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        try {
          const dataUrl = await loadBaseImage(file);
          baseImage = parseDataUrl(dataUrl);
          setStatus(baseImage ? `Loaded base image: ${file.name}` : "Base image format unsupported.");
        } catch (error) {
          setStatus(error.message);
        }
      });

      const postJson = async (url, body, key) => {
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "content-type": "application/json",
            "x-goog-api-key": key,
          },
          body: JSON.stringify(body),
        });
        const data = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(data?.error?.message || `Gemini error: ${response.status}`);
        }
        return data;
      };

      const generateImage = async (prompt, inputImage) => {
        const key = resolveKey();
        if (!key) throw new Error("Missing API key.");
        const parts = [];
        if (inputImage) {
          parts.push({
            inline_data: {
              mime_type: inputImage.mimeType,
              data: inputImage.base64,
            },
          });
        }
        parts.push({ text: prompt });
        const data = await postJson(
          `${apiBase}/models/${encodeURIComponent(resolveImageModel())}:generateContent`,
          {
            contents: [{ role: "user", parts }],
            generationConfig: { temperature: 0.2 },
          },
          key
        );
        const partsOut = data?.candidates?.[0]?.content?.parts || [];
        const inline = partsOut.find((part) => part.inlineData || part.inline_data);
        const inlineData = inline?.inlineData || inline?.inline_data;
        if (!inlineData?.data) throw new Error("No image data returned.");
        const mimeType = inlineData.mimeType || inlineData.mime_type || "image/png";
        return `data:${mimeType};base64,${inlineData.data}`;
      };

      const startVideoTask = async (prompt, inputImage, model) => {
        const key = resolveKey();
        if (!key) throw new Error("Missing API key.");
        const instance = { prompt };
        if (inputImage) {
          instance.image = {
            bytesBase64Encoded: inputImage.base64,
            mimeType: inputImage.mimeType,
          };
        }
        const data = await postJson(
          `${apiBase}/models/${encodeURIComponent(model)}:predictLongRunning`,
          {
            instances: [instance],
            parameters: {
              aspectRatio: "16:9",
              durationSeconds: 6,
              resolution: "720p",
              personGeneration: "allow_adult",
            },
          },
          key
        );
        if (!data?.name) throw new Error("No operation name returned.");
        return data.name;
      };

      const pollVideoTask = async (opName) => {
        const key = resolveKey();
        const timeoutMs = 4 * 60 * 1000;
        const started = Date.now();
        while (Date.now() - started < timeoutMs) {
          await wait(8000);
          const response = await fetch(`${apiBase}/${opName}`, {
            headers: { "x-goog-api-key": key },
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(data?.error?.message || `Veo poll error: ${response.status}`);
          }
          if (data?.done) {
            if (data?.error) {
              throw new Error(data.error.message || "Veo operation error.");
            }
            const uri =
              data?.response?.generateVideoResponse?.generatedSamples?.[0]?.video?.uri ||
              data?.response?.generatedVideos?.[0]?.video?.uri ||
              data?.response?.generated_videos?.[0]?.video?.uri;
            if (!uri) throw new Error("No video uri returned.");
            return uri;
          }
        }
        throw new Error("Video generation timed out.");
      };

      const fetchVideo = async (uri) => {
        const key = resolveKey();
        const response = await fetch(uri, { headers: { "x-goog-api-key": key } });
        if (!response.ok) {
          throw new Error(`Video download failed: ${response.status}`);
        }
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      };

      const generateForElement = async (element) => {
        const promptBase = element.dataset.prompt;
        const mode = element.dataset.gen;
        if (!promptBase || !mode) return;
        const entityId = resolveEntityForElement(element);
        const prompt = buildPrompt(promptBase, entityId);
        setStatus(`Generating ${mode.replace(/-/g, " ")} for ${entityId}...`);
        if (mode === "text-to-image") {
          const src = await generateImage(prompt);
          element.src = src;
          element.parentElement.dataset.ready = "true";
        }
        if (mode === "image-to-image") {
          if (!baseImage) throw new Error("Base image required for image-to-image.");
          const src = await generateImage(prompt, baseImage);
          element.src = src;
          element.parentElement.dataset.ready = "true";
        }
        if (mode === "text-to-video") {
          const opName = await startVideoTask(prompt, null, genVideoModel.value);
          const uri = await pollVideoTask(opName);
          const src = await fetchVideo(uri);
          element.src = src;
          element.controls = true;
          element.parentElement.dataset.ready = "true";
        }
        if (mode === "image-to-video") {
          if (!baseImage) throw new Error("Base image required for image-to-video.");
          const opName = await startVideoTask(prompt, baseImage, genVideoModel.value);
          const uri = await pollVideoTask(opName);
          const src = await fetchVideo(uri);
          element.src = src;
          element.controls = true;
          element.parentElement.dataset.ready = "true";
        }
      };

      const generateForSlide = async (slide) => {
        const targets = slide.querySelectorAll("[data-gen]");
        for (const target of targets) {
          await generateForElement(target);
        }
      };

      genToggle.addEventListener("click", () => {
        genPanel.classList.toggle("is-open");
        genPanel.setAttribute("aria-hidden", String(!genPanel.classList.contains("is-open")));
      });

      genClose.addEventListener("click", () => {
        genPanel.classList.remove("is-open");
        genPanel.setAttribute("aria-hidden", "true");
      });

      genSave.addEventListener("click", () => {
        saveKey(genKey.value.trim());
        saveImageModel(genImageModel.value.trim());
        applyBrandProfile(genEntity.value, { persist: true });
        setStatus("Saved settings to localStorage.");
      });

      genEntity.addEventListener("change", () => {
        applyBrandProfile(genEntity.value, { persist: true });
        setStatus(`Entity set to ${genEntity.value}.`);
      });

      genImageModel.addEventListener("change", () => {
        saveImageModel(genImageModel.value.trim());
        setStatus("Image model saved.");
      });

      genSlide.addEventListener("click", async () => {
        try {
          await generateForSlide(slides[currentIndex]);
          setStatus("Slide generation complete.");
        } catch (error) {
          setStatus(error.message);
        }
      });

      genAll.addEventListener("click", async () => {
        try {
          for (const slide of slides) {
            await generateForSlide(slide);
          }
          setStatus("All slide generation complete.");
        } catch (error) {
          setStatus(error.message);
        }
      });

      const urlParams = new URLSearchParams(window.location.search);
      const openNotesByDefault =
        urlParams.get("notes") === "1" || urlParams.get("presenter") === "1";
      const motionSetting = urlParams.get("motion");
      currentEntity = resolveEntity();
      populateEntitySelect();
      applyBrandProfile(currentEntity, { persist: false });
      if (genEntity) genEntity.value = currentEntity;
      genKey.value = resolveKey();
      genImageModel.value = resolveImageModel();
      updateProgress();
      gotoFromHash();
      applyEntityForSlide(slides[currentIndex]);
      updateNotesPanel(slides[currentIndex], currentIndex);
      if (motionSetting === "off" || motionSetting === "0") {
        document.body.dataset.motion = "off";
      }
      if (openNotesByDefault) {
        setNotesPanelOpen(true);
      }

      // ============================================
      // Review Mode / Comment System
      // ============================================

      const reviewToggle = document.getElementById("review-toggle");
      const identityModal = document.getElementById("identity-modal");
      const identityName = document.getElementById("identity-name");
      const identityEmail = document.getElementById("identity-email");
      const identitySave = document.getElementById("identity-save");
      const identityCancel = document.getElementById("identity-cancel");
      const commentPopover = document.getElementById("comment-popover");
      const popoverContext = document.getElementById("popover-context");
      const commentText = document.getElementById("comment-text");
      const popoverSubmit = document.getElementById("popover-submit");
      const popoverCancel = document.getElementById("popover-cancel");
      const commentSidebar = document.getElementById("comment-sidebar");
      const commentList = document.getElementById("comment-list");
      const sidebarToggle = document.getElementById("sidebar-toggle");
      const sidebarClose = document.getElementById("sidebar-close");
      const sidebarCount = document.getElementById("sidebar-count");
      const exportCommentsBtn = document.getElementById("export-comments");
      const exportMarkdownBtn = document.getElementById("export-markdown");

      const commentStorageKey = `KEYNOTE_COMMENTS_${deckId}`;
      const identityStorageKey = "KEYNOTE_REVIEWER_IDENTITY";
      let commentsData = { deckId, comments: [] };
      let isReviewMode = false;
      let currentCommentTarget = null;
      let reviewerIdentity = null;

      // Commentable element selectors
      const commentableSelectors = [
        ".title",
        ".subtitle",
        ".section-title",
        ".body-text",
        ".card",
        ".metric",
        ".quote",
        ".eyebrow",
        ".chip",
        ".media-frame",
        "[data-comment-target]",
      ].join(", ");

      const generateCommentId = () => `c_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

      const getElementSelector = (element) => {
        if (element.dataset.commentTarget) {
          return `[data-comment-target="${element.dataset.commentTarget}"]`;
        }
        const path = [];
        let el = element;
        while (el && el !== document.body) {
          let selector = el.tagName.toLowerCase();
          if (el.classList.length) {
            selector += "." + Array.from(el.classList).slice(0, 2).join(".");
          }
          const siblings = el.parentElement?.querySelectorAll(`:scope > ${el.tagName.toLowerCase()}`);
          if (siblings && siblings.length > 1) {
            const idx = Array.from(siblings).indexOf(el) + 1;
            selector += `:nth-child(${idx})`;
          }
          path.unshift(selector);
          el = el.parentElement;
        }
        return path.join(" > ");
      };

      const getElementText = (element) => {
        const text = element.textContent?.trim() || "";
        return text.length > 50 ? text.slice(0, 50) + "..." : text;
      };

      const getSlideIndex = (element) => {
        const slide = element.closest(".slide");
        return slide ? slides.indexOf(slide) : -1;
      };

      const loadComments = () => {
        try {
          const stored = localStorage.getItem(commentStorageKey);
          if (stored) {
            commentsData = JSON.parse(stored);
          }
        } catch {
          commentsData = { deckId, comments: [] };
        }
        renderCommentIndicators();
        updateSidebarCount();
      };

      const saveComments = () => {
        localStorage.setItem(commentStorageKey, JSON.stringify(commentsData));
        renderCommentIndicators();
        updateSidebarCount();
      };

      const loadIdentity = () => {
        try {
          const stored = sessionStorage.getItem(identityStorageKey);
          if (stored) {
            reviewerIdentity = JSON.parse(stored);
          }
        } catch {
          reviewerIdentity = null;
        }
      };

      const saveIdentity = (name, email) => {
        reviewerIdentity = { name, email };
        sessionStorage.setItem(identityStorageKey, JSON.stringify(reviewerIdentity));
      };

      const promptForIdentity = () => {
        return new Promise((resolve, reject) => {
          if (reviewerIdentity) {
            resolve(reviewerIdentity);
            return;
          }
          identityModal.classList.add("is-open");
          identityModal.setAttribute("aria-hidden", "false");
          identityName.focus();

          const handleSave = () => {
            const name = identityName.value.trim();
            const email = identityEmail.value.trim();
            if (!name || !email) {
              identityName.style.borderColor = name ? "" : "var(--brand-accent)";
              identityEmail.style.borderColor = email ? "" : "var(--brand-accent)";
              return;
            }
            saveIdentity(name, email);
            closeIdentityModal();
            resolve(reviewerIdentity);
          };

          const handleCancel = () => {
            closeIdentityModal();
            reject(new Error("Identity cancelled"));
          };

          const closeIdentityModal = () => {
            identityModal.classList.remove("is-open");
            identityModal.setAttribute("aria-hidden", "true");
            identitySave.removeEventListener("click", handleSave);
            identityCancel.removeEventListener("click", handleCancel);
          };

          identitySave.addEventListener("click", handleSave);
          identityCancel.addEventListener("click", handleCancel);
        });
      };

      const enterReviewMode = () => {
        isReviewMode = true;
        document.body.classList.add("review-mode");
        reviewToggle.classList.add("is-active");
        reviewToggle.textContent = "Exit Review";

        document.querySelectorAll(commentableSelectors).forEach((el) => {
          if (!el.closest(".slide-notes") && !el.closest("template")) {
            el.classList.add("commentable");
          }
        });
        renderCommentIndicators();
      };

      const exitReviewMode = () => {
        isReviewMode = false;
        document.body.classList.remove("review-mode");
        reviewToggle.classList.remove("is-active");
        reviewToggle.textContent = "Review";

        document.querySelectorAll(".commentable").forEach((el) => {
          el.classList.remove("commentable");
        });
        closeCommentPopover();
        closeSidebar();
      };

      const toggleReviewMode = () => {
        if (isReviewMode) {
          exitReviewMode();
        } else {
          enterReviewMode();
        }
      };

      const openCommentPopover = (element, rect) => {
        currentCommentTarget = element;
        popoverContext.textContent = getElementText(element);
        commentText.value = "";

        const popoverWidth = 320;
        const popoverHeight = 180;
        let left = rect.left + rect.width / 2 - popoverWidth / 2;
        let top = rect.bottom + 12;

        if (left < 16) left = 16;
        if (left + popoverWidth > window.innerWidth - 16) {
          left = window.innerWidth - popoverWidth - 16;
        }
        if (top + popoverHeight > window.innerHeight - 16) {
          top = rect.top - popoverHeight - 12;
        }

        commentPopover.style.left = `${left}px`;
        commentPopover.style.top = `${top}px`;
        commentPopover.classList.add("is-open");
        commentText.focus();
      };

      const closeCommentPopover = () => {
        commentPopover.classList.remove("is-open");
        currentCommentTarget = null;
        commentText.value = "";
      };

      const addComment = async (element, text) => {
        const identity = await promptForIdentity();
        const slideIndex = getSlideIndex(element);
        const slide = slides[slideIndex];

        const comment = {
          id: generateCommentId(),
          slideIndex,
          slideTitle: slide?.dataset?.title || `Slide ${slideIndex + 1}`,
          elementSelector: getElementSelector(element),
          elementText: getElementText(element),
          comment: text,
          author: {
            name: identity.name,
            email: identity.email,
          },
          createdAt: new Date().toISOString(),
          resolved: false,
        };

        commentsData.comments.push(comment);
        saveComments();
        renderSidebar();
      };

      const resolveComment = (commentId) => {
        const comment = commentsData.comments.find((c) => c.id === commentId);
        if (comment) {
          comment.resolved = !comment.resolved;
          saveComments();
          renderSidebar();
        }
      };

      const deleteComment = (commentId) => {
        commentsData.comments = commentsData.comments.filter((c) => c.id !== commentId);
        saveComments();
        renderSidebar();
      };

      const renderCommentIndicators = () => {
        document.querySelectorAll(".comment-indicator").forEach((el) => el.remove());
        document.querySelectorAll(".has-comments").forEach((el) => el.classList.remove("has-comments"));

        if (!isReviewMode) return;

        const commentsBySelector = {};
        commentsData.comments
          .filter((c) => !c.resolved)
          .forEach((c) => {
            if (!commentsBySelector[c.elementSelector]) {
              commentsBySelector[c.elementSelector] = [];
            }
            commentsBySelector[c.elementSelector].push(c);
          });

        Object.entries(commentsBySelector).forEach(([selector, comments]) => {
          try {
            const element = document.querySelector(selector);
            if (element && !element.closest("template")) {
              element.classList.add("has-comments");
              element.style.position = element.style.position || "relative";
              const badge = document.createElement("span");
              badge.className = "comment-indicator";
              badge.textContent = comments.length;
              element.appendChild(badge);
            }
          } catch {}
        });
      };

      const updateSidebarCount = () => {
        const unresolvedCount = commentsData.comments.filter((c) => !c.resolved).length;
        sidebarCount.textContent = unresolvedCount;
      };

      const openSidebar = () => {
        renderSidebar();
        commentSidebar.classList.add("is-open");
        commentSidebar.setAttribute("aria-hidden", "false");
      };

      const closeSidebar = () => {
        commentSidebar.classList.remove("is-open");
        commentSidebar.setAttribute("aria-hidden", "true");
      };

      const toggleSidebar = () => {
        if (commentSidebar.classList.contains("is-open")) {
          closeSidebar();
        } else {
          openSidebar();
        }
      };

      const formatTime = (isoString) => {
        const date = new Date(isoString);
        return date.toLocaleDateString() + " " + date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      };

      const renderSidebar = () => {
        if (!commentsData.comments.length) {
          commentList.innerHTML = '<div class="comment-list-empty">No comments yet. Click on elements in review mode to add feedback.</div>';
          return;
        }

        const grouped = {};
        commentsData.comments.forEach((c) => {
          const key = c.slideIndex;
          if (!grouped[key]) grouped[key] = [];
          grouped[key].push(c);
        });

        let html = "";
        Object.keys(grouped)
          .sort((a, b) => Number(a) - Number(b))
          .forEach((slideIndex) => {
            const comments = grouped[slideIndex];
            const slideTitle = comments[0].slideTitle;
            html += `<div style="font-size: 0.85rem; color: rgba(247,241,232,0.6); margin: 16px 0 8px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 6px;">Slide ${Number(slideIndex) + 1}: ${slideTitle}</div>`;
            comments.forEach((c) => {
              html += `
                <div class="comment-item ${c.resolved ? "is-resolved" : ""}" data-comment-id="${c.id}">
                  <div class="comment-item-header">
                    <span class="comment-item-author">${c.author.name}</span>
                    <span class="comment-item-time">${formatTime(c.createdAt)}</span>
                  </div>
                  <div class="comment-item-context">"${c.elementText}"</div>
                  <div class="comment-item-text">${c.comment}</div>
                  <div class="comment-item-actions">
                    <button type="button" data-action="resolve" data-id="${c.id}">${c.resolved ? "Unresolve" : "Resolve"}</button>
                    <button type="button" data-action="delete" data-id="${c.id}">Delete</button>
                    <button type="button" data-action="goto" data-slide="${c.slideIndex}">Go to slide</button>
                  </div>
                </div>
              `;
            });
          });

        commentList.innerHTML = html;
      };

      const exportCommentsJson = () => {
        const blob = new Blob([JSON.stringify(commentsData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `comments-${deckId}.json`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      };

      const exportCommentsMarkdown = () => {
        const deckTitle = deckConfig.title || document.title || "Deck";
        const lines = [`# Feedback: ${deckTitle}`, "", `Generated: ${new Date().toISOString()}`, ""];

        const grouped = {};
        commentsData.comments.forEach((c) => {
          if (!grouped[c.slideIndex]) grouped[c.slideIndex] = [];
          grouped[c.slideIndex].push(c);
        });

        Object.keys(grouped)
          .sort((a, b) => Number(a) - Number(b))
          .forEach((slideIndex) => {
            const comments = grouped[slideIndex];
            const slideTitle = comments[0].slideTitle;
            lines.push(`## Slide ${Number(slideIndex) + 1}: ${slideTitle}`);
            lines.push("");
            comments.forEach((c) => {
              const status = c.resolved ? "[RESOLVED]" : "[OPEN]";
              lines.push(`### ${status} ${c.author.name} (${c.author.email})`);
              lines.push(`> "${c.elementText}"`);
              lines.push("");
              lines.push(c.comment);
              lines.push("");
              lines.push(`*${formatTime(c.createdAt)}*`);
              lines.push("");
            });
          });

        const blob = new Blob([lines.join("\n")], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `feedback-${deckId}.md`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      };

      // Event listeners for review mode
      reviewToggle?.addEventListener("click", toggleReviewMode);
      sidebarToggle?.addEventListener("click", toggleSidebar);
      sidebarClose?.addEventListener("click", closeSidebar);
      exportCommentsBtn?.addEventListener("click", exportCommentsJson);
      exportMarkdownBtn?.addEventListener("click", exportCommentsMarkdown);

      popoverCancel?.addEventListener("click", closeCommentPopover);
      popoverSubmit?.addEventListener("click", async () => {
        const text = commentText.value.trim();
        if (!text || !currentCommentTarget) return;
        try {
          await addComment(currentCommentTarget, text);
          closeCommentPopover();
        } catch {}
      });

      commentList?.addEventListener("click", (event) => {
        const btn = event.target.closest("button[data-action]");
        if (!btn) return;
        const action = btn.dataset.action;
        const id = btn.dataset.id;
        const slideIndex = btn.dataset.slide;

        if (action === "resolve" && id) resolveComment(id);
        if (action === "delete" && id) deleteComment(id);
        if (action === "goto" && slideIndex !== undefined) {
          showSlide(Number(slideIndex));
          closeSidebar();
        }
      });

      document.addEventListener("click", (event) => {
        if (!isReviewMode) return;
        const target = event.target.closest(".commentable");
        if (!target) return;
        if (event.target.closest(".comment-popover, .comment-sidebar, .identity-modal")) return;

        event.preventDefault();
        event.stopPropagation();
        const rect = target.getBoundingClientRect();
        openCommentPopover(target, rect);
      });

      // Close popover on escape
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          if (commentPopover.classList.contains("is-open")) {
            closeCommentPopover();
          } else if (commentSidebar.classList.contains("is-open")) {
            closeSidebar();
          } else if (identityModal.classList.contains("is-open")) {
            identityModal.classList.remove("is-open");
          }
        }
        // Toggle review mode with 'r' key
        if (event.key.toLowerCase() === "r" && !event.target.closest("input, textarea, select, [contenteditable]")) {
          event.preventDefault();
          toggleReviewMode();
        }
        // Toggle sidebar with 'c' key in review mode
        if (event.key.toLowerCase() === "c" && isReviewMode && !event.target.closest("input, textarea, select, [contenteditable]")) {
          event.preventDefault();
          toggleSidebar();
        }
      });

      // Check for review mode URL param
      const reviewParam = urlParams.get("review");
      if (reviewParam === "1" || reviewParam === "true") {
        enterReviewMode();
      }

      // Initialize comment system
      loadIdentity();
      loadComments();
    </script>
  </body>
</html>
